<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Familien Stammbaum</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }

        .header h1 {
            font-size: 24px;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #764ba2;
        }

        .btn-edit {
            background: #4CAF50;
        }

        .btn-edit:hover {
            background: #45a049;
        }

        #canvas-container {
            flex: 1;
            overflow: hidden;
            position: relative;
            background: #f8f9fa;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        /* Dot pattern background */
        #canvas-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: radial-gradient(circle, #ccc 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
            opacity: 0.5;
        }

        #tree-viewport {
            position: absolute;
            transform-origin: 0 0;
            will-change: transform;
        }

        .couple-container {
            position: absolute;
            display: flex;
            align-items: flex-start;
            gap: 20px;
        }

        .person-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            padding: 15px;
            text-align: center;
            width: 150px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            position: relative;
        }

        .person-card:hover {
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25);
            transform: translateY(-3px);
        }

        .person-card.male {
            border-top: 4px solid #2196F3;
        }

        .person-card.female {
            border-top: 4px solid #E91E63;
        }

        .person-image {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid #667eea;
            margin-bottom: 10px;
        }

        .person-name {
            font-weight: 600;
            font-size: 14px;
            color: #333;
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .person-dates {
            font-size: 11px;
            color: #666;
            line-height: 1.4;
        }

        .person-dates .alive {
            color: #4CAF50;
            font-weight: 600;
        }

        .person-dates .deceased {
            color: #999;
        }

        /* SVG f√ºr Linien */
        #lines-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }

        .marriage-line {
            stroke: #E91E63;
            stroke-width: 3;
            fill: none;
            stroke-dasharray: none;
        }

        .child-line {
            stroke: #4CAF50;
            stroke-width: 2.5;
            fill: none;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: #667eea;
            color: white;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
            font-size: 12px;
            z-index: 10;
        }

        .legend h4 {
            margin-bottom: 10px;
            color: #333;
            font-size: 13px;
        }

        .legend-item {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-line {
            width: 30px;
            height: 3px;
        }

        .legend-line.marriage {
            background: #E91E63;
        }

        .legend-line.child {
            background: #4CAF50;
        }

        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #666;
        }

        .empty-state h2 {
            margin-bottom: 15px;
            color: #333;
        }

        .empty-state a {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            text-decoration: none;
            margin-top: 15px;
            transition: background 0.3s;
        }

        .empty-state a:hover {
            background: #764ba2;
        }

        .zoom-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 12px;
            color: #666;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå≥ Familien Stammbaum</h1>
            <div class="header-buttons">
                <button class="btn" onclick="fitToScreen()">Anpassen</button>
                <button class="btn" onclick="resetView()">Zur√ºcksetzen</button>
                <a href="/edit" class="btn btn-edit" style="text-decoration: none;">‚úèÔ∏è Bearbeiten</a>
            </div>
        </div>
        <div id="canvas-container">
            <div id="tree-viewport">
                <svg id="lines-svg"></svg>
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()" title="Vergr√∂√üern">+</button>
                <button class="zoom-btn" onclick="zoomOut()" title="Verkleinern">‚àí</button>
            </div>
            <div class="legend">
                <h4>Legende</h4>
                <div class="legend-item">
                    <div class="legend-line marriage"></div>
                    <span>Ehe / Partnerschaft</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line child"></div>
                    <span>Eltern-Kind</span>
                </div>
            </div>
            <div class="zoom-info" id="zoomInfo">100%</div>
        </div>
    </div>

    <script>
        // ===== Konfiguration =====
        const CONFIG = {
            CARD_WIDTH: 150,
            CARD_HEIGHT: 160,
            COUPLE_GAP: 30,          // Abstand zwischen Ehepartnern
            SIBLING_GAP: 40,         // Abstand zwischen Geschwistern
            GENERATION_GAP: 200,     // Vertikaler Abstand zwischen Generationen
            TREE_GAP: 150,           // Abstand zwischen separaten B√§umen
            INITIAL_OFFSET_X: 100,
            INITIAL_OFFSET_Y: 100
        };

        // ===== State =====
        let scale = 1;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let treeData = null;
        let allPersonsById = new Map();
        let nodePositions = new Map(); // id -> {x, y, width, height}

        // ===== DOM Elemente =====
        const container = document.getElementById('canvas-container');
        const viewport = document.getElementById('tree-viewport');
        const linesSvg = document.getElementById('lines-svg');
        const zoomInfo = document.getElementById('zoomInfo');

        // ===== Pan & Zoom (Miro-Style) =====
        function updateTransform() {
            viewport.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            zoomInfo.textContent = Math.round(scale * 100) + '%';
        }

        // Maus-Drag f√ºr Pan
        container.addEventListener('mousedown', (e) => {
            if (e.target === container || e.target === viewport || e.target === linesSvg) {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                container.style.cursor = 'grabbing';
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                panX += dx;
                panY += dy;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                updateTransform();
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            container.style.cursor = 'grab';
        });

        // Mausrad f√ºr Zoom
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const rect = container.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Zoom-Faktor
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(3, scale * zoomFactor));
            
            // Zoom zum Mauszeiger
            const scaleChange = newScale / scale;
            panX = mouseX - (mouseX - panX) * scaleChange;
            panY = mouseY - (mouseY - panY) * scaleChange;
            
            scale = newScale;
            updateTransform();
        }, { passive: false });

        // Touch-Support f√ºr Mobile
        let lastTouchDist = 0;
        container.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                lastTouchDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        }, { passive: false });

        container.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && isDragging) {
                const dx = e.touches[0].clientX - lastMouseX;
                const dy = e.touches[0].clientY - lastMouseY;
                panX += dx;
                panY += dy;
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
                updateTransform();
            } else if (e.touches.length === 2) {
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                const zoomFactor = dist / lastTouchDist;
                scale = Math.max(0.1, Math.min(3, scale * zoomFactor));
                lastTouchDist = dist;
                updateTransform();
            }
        }, { passive: false });

        container.addEventListener('touchend', () => {
            isDragging = false;
        });

        // ===== Zoom Buttons =====
        function zoomIn() {
            const rect = container.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            const newScale = Math.min(3, scale * 1.2);
            const scaleChange = newScale / scale;
            panX = centerX - (centerX - panX) * scaleChange;
            panY = centerY - (centerY - panY) * scaleChange;
            
            scale = newScale;
            updateTransform();
        }

        function zoomOut() {
            const rect = container.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            const newScale = Math.max(0.1, scale / 1.2);
            const scaleChange = newScale / scale;
            panX = centerX - (centerX - panX) * scaleChange;
            panY = centerY - (centerY - panY) * scaleChange;
            
            scale = newScale;
            updateTransform();
        }

        function resetView() {
            scale = 1;
            panX = CONFIG.INITIAL_OFFSET_X;
            panY = CONFIG.INITIAL_OFFSET_Y;
            updateTransform();
        }

        function fitToScreen() {
            if (nodePositions.size === 0) return;
            
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            nodePositions.forEach(pos => {
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x + pos.width);
                minY = Math.min(minY, pos.y);
                maxY = Math.max(maxY, pos.y + pos.height);
            });
            
            const treeWidth = maxX - minX + 100;
            const treeHeight = maxY - minY + 100;
            const containerRect = container.getBoundingClientRect();
            
            scale = Math.min(
                (containerRect.width - 100) / treeWidth,
                (containerRect.height - 100) / treeHeight,
                1.5
            );
            scale = Math.max(0.3, scale);
            
            panX = (containerRect.width - treeWidth * scale) / 2 - minX * scale + 50;
            panY = (containerRect.height - treeHeight * scale) / 2 - minY * scale + 50;
            
            updateTransform();
        }

        // ===== Daten laden =====
        async function loadTreeData() {
            try {
                const response = await fetch('/api/persons/tree');
                const data = await response.json();
                
                if (data.length === 0) {
                    showEmptyState();
                    return;
                }
                
                treeData = data;
                buildPersonIndex(data);
                layoutTree(data);
                renderTree();
                
                setTimeout(fitToScreen, 100);
            } catch (error) {
                console.error('Fehler beim Laden:', error);
            }
        }

        function buildPersonIndex(trees) {
            allPersonsById.clear();
            
            function indexPerson(person) {
                if (!person || allPersonsById.has(person.id)) return;
                allPersonsById.set(person.id, person);
                
                // Indexiere Ehegatte auch (f√ºr Linien-Zeichnung)
                if (person.ehegatte) {
                    allPersonsById.set(person.ehegatte.id, person.ehegatte);
                }

                // Indexiere Kinder rekursiv
                if (person.children) {
                    person.children.forEach(indexPerson);
                }
            }
            
            // Indexiere alle Personen in den B√§umen
            trees.forEach(indexPerson);
        }

        function showEmptyState() {
            viewport.innerHTML = `
                <div class="empty-state">
                    <h2>Noch keine Personen im Stammbaum</h2>
                    <p>F√ºgen Sie Ihre erste Person hinzu, um den Stammbaum zu starten.</p>
                    <a href="/edit">‚ûï Person hinzuf√ºgen</a>
                </div>
            `;
        }

        // ===== Layout-Berechnung =====
        function layoutTree(trees) {
            nodePositions.clear();
            let currentX = 0;

            trees.forEach((tree, index) => {
                const treeWidth = calculateSubtreeWidth(tree);

                // Layout f√ºr diesen Baum
                layoutSubtree(tree, currentX + 50, 50, 0);

                // N√§chster Baum rechts davon
                currentX += treeWidth + CONFIG.TREE_GAP + 100;
            });
        }

        function calculateSubtreeHeight(person, currentLevel = 0) {
            if (!person) return 0;

            if (!person.children || person.children.length === 0) {
                return CONFIG.CARD_HEIGHT + (currentLevel * CONFIG.GENERATION_GAP);
            }

            let maxHeight = 0;
            person.children.forEach(child => {
                const childHeight = calculateSubtreeHeight(child, currentLevel + 1);
                maxHeight = Math.max(maxHeight, childHeight);
            });

            return CONFIG.CARD_HEIGHT + CONFIG.GENERATION_GAP + maxHeight;
        }

        function layoutSubtree(person, startX, startY, level) {
            if (!person || nodePositions.has(person.id)) return 0;
            
            const y = startY + (level * CONFIG.GENERATION_GAP);
            const hasSpouse = person.ehegatte && !nodePositions.has(person.ehegatte.id);
            
            // Berechne Breite f√ºr Kinder
            let childrenWidth = 0;
            const childWidths = [];

            if (person.children && person.children.length > 0) {
                person.children.forEach(child => {
                    const childWidth = calculateSubtreeWidth(child);
                    childWidths.push(childWidth);
                    childrenWidth += childWidth;
                });
                if (person.children.length > 1) {
                    childrenWidth += (person.children.length - 1) * CONFIG.SIBLING_GAP;
                }
            }

            // Breite dieser Familie (Paar oder einzeln)
            const coupleWidth = hasSpouse 
                ? CONFIG.CARD_WIDTH * 2 + CONFIG.COUPLE_GAP 
                : CONFIG.CARD_WIDTH;
            
            // Nutze die gr√∂√üere Breite: Paar oder Kinder
            const totalWidth = Math.max(coupleWidth, childrenWidth);

            // Zentriere das Paar in dieser Breite
            const coupleStartX = startX + (totalWidth - coupleWidth) / 2;
            const centerX = coupleStartX + coupleWidth / 2;

            // Positioniere Hauptperson
            const personX = hasSpouse
                ? centerX - CONFIG.CARD_WIDTH - CONFIG.COUPLE_GAP / 2
                : centerX - CONFIG.CARD_WIDTH / 2;
            
            nodePositions.set(person.id, {
                x: personX,
                y: y,
                width: CONFIG.CARD_WIDTH,
                height: CONFIG.CARD_HEIGHT,
                hasSpouse: hasSpouse,
                spouseId: hasSpouse ? person.ehegatte.id : null,
                centerX: centerX,
                level: level
            });
            
            // Positioniere Ehepartner
            if (hasSpouse) {
                const spouseX = centerX + CONFIG.COUPLE_GAP / 2;
                nodePositions.set(person.ehegatte.id, {
                    x: spouseX,
                    y: y,
                    width: CONFIG.CARD_WIDTH,
                    height: CONFIG.CARD_HEIGHT,
                    hasSpouse: true,
                    spouseId: person.id,
                    centerX: centerX,
                    level: level
                });
            }
            
            // Positioniere Kinder - jedes Kind zentriert √ºber seinen eigenen Kindern
            if (person.children && person.children.length > 0) {
                let childX = startX + (totalWidth - childrenWidth) / 2;

                person.children.forEach((child, index) => {
                    layoutSubtree(child, childX, startY, level + 1);
                    childX += childWidths[index] + CONFIG.SIBLING_GAP;
                });
            }
            
            return totalWidth;
        }

        function calculateSubtreeWidth(person) {
            if (!person) return 0;
            
            const hasSpouse = person.ehegatte != null;
            const coupleWidth = hasSpouse 
                ? CONFIG.CARD_WIDTH * 2 + CONFIG.COUPLE_GAP 
                : CONFIG.CARD_WIDTH;
            
            if (!person.children || person.children.length === 0) {
                return coupleWidth;
            }
            
            let childrenWidth = 0;
            person.children.forEach((child, index) => {
                childrenWidth += calculateSubtreeWidth(child);
                if (index < person.children.length - 1) {
                    childrenWidth += CONFIG.SIBLING_GAP;
                }
            });
            
            return Math.max(coupleWidth, childrenWidth);
        }

        // ===== Rendering =====
        function renderTree() {
            // L√∂sche altes Rendering
            viewport.innerHTML = '<svg id="lines-svg"></svg>';
            const newLinesSvg = document.getElementById('lines-svg');
            
            // Bestimme SVG-Gr√∂√üe
            let maxX = 0, maxY = 0;
            nodePositions.forEach(pos => {
                maxX = Math.max(maxX, pos.x + pos.width + 100);
                maxY = Math.max(maxY, pos.y + pos.height + 100);
            });
            newLinesSvg.style.width = maxX + 'px';
            newLinesSvg.style.height = maxY + 'px';
            
            // Zeichne Linien
            drawConnections(newLinesSvg);
            
            // Erstelle Personen-Karten
            nodePositions.forEach((pos, personId) => {
                const person = allPersonsById.get(personId);
                if (person) {
                    createPersonCard(person, pos);
                }
            });
        }

        function drawConnections(svg) {
            // Schritt 1: Zeichne alle Ehe-Linien (ZUERST)
            const drawnMarriages = new Set();
            
            nodePositions.forEach((pos, personId) => {
                if (pos.hasSpouse && pos.spouseId) {
                    const key = [personId, pos.spouseId].sort().join('-');
                    if (!drawnMarriages.has(key)) {
                        drawnMarriages.add(key);
                        const spousePos = nodePositions.get(pos.spouseId);
                        if (spousePos) {
                            const y = pos.y + CONFIG.CARD_HEIGHT / 2;
                            const x1 = pos.x + CONFIG.CARD_WIDTH;
                            const x2 = spousePos.x;
                            
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', x1);
                            line.setAttribute('y1', y);
                            line.setAttribute('x2', x2);
                            line.setAttribute('y2', y);
                            line.setAttribute('class', 'marriage-line');
                            svg.appendChild(line);
                        }
                    }
                }
            });
            
            // Schritt 2: Zeichne alle Eltern-Kind-Linien
            if (treeData) {
                treeData.forEach(tree => drawChildConnections(svg, tree, null));
            }
        }

        function drawChildConnections(svg, person, parentCenterX) {
            if (!person || !person.children || person.children.length === 0) return;
            
            const parentPos = nodePositions.get(person.id);
            if (!parentPos) return;
            
            // Berechne Mittelpunkt dieser Elterngruppe (Person + Ehegatte falls vorhanden)
            let thisCenterX = parentPos.x + CONFIG.CARD_WIDTH / 2;
            if (parentPos.hasSpouse && parentPos.spouseId) {
                const spousePos = nodePositions.get(parentPos.spouseId);
                if (spousePos) {
                    thisCenterX = (parentPos.x + CONFIG.CARD_WIDTH + spousePos.x) / 2;
                }
            }
            
            const parentBottomY = parentPos.y + CONFIG.CARD_HEIGHT;
            const nextLevelY = parentPos.y + CONFIG.GENERATION_GAP;
            const midY = parentBottomY + (CONFIG.GENERATION_GAP - CONFIG.CARD_HEIGHT) / 2;
            
            // Sammle alle Kind-Zentren
            const childCenters = [];
            const childPositions = [];

            person.children.forEach(child => {
                const childPos = nodePositions.get(child.id);
                if (childPos) {
                    let childCenterX = childPos.x + CONFIG.CARD_WIDTH / 2;
                    if (childPos.hasSpouse && childPos.spouseId) {
                        const childSpousePos = nodePositions.get(childPos.spouseId);
                        if (childSpousePos) {
                            childCenterX = (childPos.x + CONFIG.CARD_WIDTH + childSpousePos.x) / 2;
                        }
                    }
                    childCenters.push(childCenterX);
                    childPositions.push({ x: childCenterX, y: childPos.y });
                }
            });
            
            if (childCenters.length === 0) return;

            // ===== LINIEN-STRUKTUR =====
            // 1. Vertikale Linie von Eltern nach unten
            const vLine1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            vLine1.setAttribute('x1', thisCenterX);
            vLine1.setAttribute('y1', parentBottomY);
            vLine1.setAttribute('x2', thisCenterX);
            vLine1.setAttribute('y2', midY);
            vLine1.setAttribute('class', 'child-line');
            svg.appendChild(vLine1);

            // 2. Horizontale Linie √ºber den Kindern
            const minChildX = Math.min(...childCenters);
            const maxChildX = Math.max(...childCenters);

            if (childCenters.length === 1) {
                // Einzelnes Kind: Gerade Linie von Eltern zu Kind
                const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hLine.setAttribute('x1', thisCenterX);
                hLine.setAttribute('y1', midY);
                hLine.setAttribute('x2', childCenters[0]);
                hLine.setAttribute('y2', midY);
                hLine.setAttribute('class', 'child-line');
                svg.appendChild(hLine);

                // Vertikale Linie zum Kind
                const vLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                vLine2.setAttribute('x1', childCenters[0]);
                vLine2.setAttribute('y1', midY);
                vLine2.setAttribute('x2', childCenters[0]);
                vLine2.setAttribute('y2', childPositions[0].y);
                vLine2.setAttribute('class', 'child-line');
                svg.appendChild(vLine2);
            } else {
                // Mehrere Kinder: T-Form Struktur
                // Horizontale Linie √ºber alle Kinder
                const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hLine.setAttribute('x1', minChildX);
                hLine.setAttribute('y1', midY);
                hLine.setAttribute('x2', maxChildX);
                hLine.setAttribute('y2', midY);
                hLine.setAttribute('class', 'child-line');
                svg.appendChild(hLine);

                // Verbindung von Eltern zur horizontalen Linie
                const hConnectLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hConnectLine.setAttribute('x1', thisCenterX);
                hConnectLine.setAttribute('y1', midY);
                hConnectLine.setAttribute('x2', (minChildX + maxChildX) / 2);
                hConnectLine.setAttribute('y2', midY);
                hConnectLine.setAttribute('class', 'child-line');
                svg.appendChild(hConnectLine);

                // Vertikale Linien von horizontaler Linie zu jedem Kind
                childPositions.forEach((childPos, index) => {
                    const vLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    vLine2.setAttribute('x1', childPos.x);
                    vLine2.setAttribute('y1', midY);
                    vLine2.setAttribute('x2', childPos.x);
                    vLine2.setAttribute('y2', childPos.y);
                    vLine2.setAttribute('class', 'child-line');
                    svg.appendChild(vLine2);
                });
            }
            
            // 3. Rekursiv f√ºr Kinder
            person.children.forEach(child => {
                drawChildConnections(svg, child, thisCenterX);
            });
        }

        function createPersonCard(person, pos) {
            const card = document.createElement('div');
            card.className = 'person-card';
            card.style.left = pos.x + 'px';
            card.style.top = pos.y + 'px';
            
            let datesHtml = '';
            if (person.geburtsdatum) {
                datesHtml = `<div class="person-dates">* ${formatDate(person.geburtsdatum)}`;
                if (person.todesdatum) {
                    datesHtml += `<br><span class="deceased">üïäÔ∏è ${formatDate(person.todesdatum)}</span>`;
                } else {
                    datesHtml += ` <span class="alive">(lebend)</span>`;
                }
                datesHtml += '</div>';
            }
            
            card.innerHTML = `
                <img src="${person.bildpfad || '/placeholder.png'}" 
                     alt="${person.fullName}" 
                     class="person-image" 
                     onerror="this.src='/placeholder.png'">
                <div class="person-name">${person.fullName || person.vorname + ' ' + person.nachname}</div>
                ${datesHtml}
            `;
            
            card.addEventListener('click', (e) => {
                e.stopPropagation();
                window.location.href = `/edit?id=${person.id}`;
            });
            
            viewport.appendChild(card);
        }

        function formatDate(dateString) {
            if (!dateString) return '?';
            const date = new Date(dateString);
            return date.toLocaleDateString('de-DE', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric'
            });
        }

        // ===== Start =====
        window.addEventListener('load', () => {
            resetView();
            loadTreeData();
        });

        window.addEventListener('resize', () => {
            if (treeData) {
                setTimeout(fitToScreen, 100);
            }
        });
    </script>
</body>
</html>
